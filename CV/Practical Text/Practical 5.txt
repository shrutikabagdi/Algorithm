Aim: Apply following image processing operation on the given image. 
i. Negative ii. Logarithmic iii. Affine iv. Cropping 


THEORY: 
● Negative 
The negative of an image with gray level in the range [0, L-1], where L = Largest value in an 
image, is obtained by using the negative transformation’s expression: 
                                                                         s = L – 1 – r 
Which reverses the intensity levels of an input image, in this manner produces the equivalent 
of a photographic negative. The negative transformation is suitable for enhancing white or 
gray detail embedded in dark regions of an image, especially when the black area is dominant 
in size. 
Example:
 
Advantages of Negative image: 
Advantages of negative: 
● Produces an equivalent of a photographic negative. 
● Enhances white or gray detail embedded in dark regions. 


●Logarithmic 
The general form of the log transformation: 
s = c log (1+r). 
Where c is a constant, and r ≥ 0  
Log curve maps a narrow range of low gray-level values in the input image into a wider range of the 
output levels. Used to expand the values of dark pixels in an image while compressing the higher
level values.  
It compresses the dynamic range of images with large variations in pixel values. Log functions are 
particularly useful when the input grey level values may have an extremely large range of values.


● Affine 
An affine transformation is a transformation that preserves co-linearity and the ratio of distances. 
The parallel lines in an original image will be parallel in the output image. 
Affine= Translation + Rotation + Scale + Shear 


● Cropping 
As the name suggests, cropping is the act of selecting and extracting the Region of Interest (or 
simply, ROI) and is the part of the image in which we are interested. For instance, in a face detection 
application, we may want to crop the face from an image. 
When we crop an image, we want to remove the outer parts of the image we are not interested in. 
We commonly refer to this process as selecting our Region of Interest, or more simply, our ROI. 
We can accomplish image cropping by using NumPy array slicing. 



Code:

#1. Negative
#Example 1
import cv2
import numpy as np
#Load the data
img=cv2.imread("D:\PyCharm\Practical 5\Flower.jpg")
#Check the datatype of the image
print(img.dtype)
img_neg=255-img
img3=cv2.hconcat([img,img_neg])
cv2.imshow('Original img and negative img',img3)
cv2.waitKey(0)
cv2.destroyAllWindows()



#2.Logarithmic
import cv2
import numpy as np
image = cv2.imread("D:\PyCharm\Practical 5\Flower.jpg")
# Convert to float64 for processing
image_float = image.astype(np.float64)
# Replace negative values (if any) with 0
image_float[image_float < 0] = 0
max_val = np.max(image_float)
 # Calculate constant c for log transform
c = 255 / np.log(1 + max_val)
# Apply log transform
log_image = c * np.log(1 + image_float)
# Clip to valid range and convert to uint8
log_image = np.clip(log_image, 0, 255).astype(np.uint8)
# Concatenate original and log-transformed images horizontally
img3 = cv2.hconcat([image, log_image])
# Show the result
cv2.imshow('Original Image and Logarithmic Image', img3)
cv2.waitKey(0)
cv2.destroyAllWindows()



#3.Affine
import cv2
import numpy as np
img=cv2.imread("D:\PyCharm\Practical 5\Flower.jpg")
rows,cols,ch=img.shape
pts1=np.float32([[50,50],[200,50],[50,200]])
pts2=np.float32([[10,100],[200,50],[100,250]])
M=cv2.getAffineTransform(pts1,pts2)
dst=cv2.warpAffine(img,M,(cols,rows))
cv2.imshow('Affineimage',dst)
cv2.waitKey(0)
cv2.destroyAllWindows()



#4.Cropping
import cv2
import numpy as np
img=cv2.imread("D:\PyCharm\Practical 5\Flower.jpg")
cropped_img=img[200:500,200:500]
cv2.imshow('cropping image',cropped_img)
cv2.waitKey(0)
cv2.destroyAllWindows()