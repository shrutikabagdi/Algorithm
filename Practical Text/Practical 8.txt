AIM: To study and implement Indexing in MongoDB using 
1. Single Field Index 
2. Compound Index 
3. Unique Index 
4. Text Index 
and analyze query performance using .explain(“executionStats”).

THEORY: 
Introduction: MongoDB indexes are crucial in optimizing database performance, as they improve the 
speed of data retrieval operations in a MongoDB database. They create a reference to the location of data 
within a collection based on the indexed field(s). When a query involves the indexed field, MongoDB can 
use the index to rapidly pinpoint the relevant documents, resulting in faster query execution times. By 
expediting data retrieval through efficient query execution, MongoDB indexes enhance the performance of 
your database. 
MongoDB Indexes Importance: -  
MongoDB indexes play a pivotal role in enhancing query performance and improving overall database 
efficiency. They enable MongoDB to retrieve data by providing a roadmap for the database to locate 
specific data quickly. 

Use Indexes in MongoDB:-
 
Accelerating Queries: Indexes dramatically enhance query execution for frequently accessed fields, 
leading to quicker data retrieval and overall application responsiveness. 

Sorting and Aggregation: Indexes expedite sorting and aggregation tasks, enabling efficient data 
manipulation for reports, analytics, and visualization. 

Range-based Queries: Indexes bolster range-based queries, essential for retrieving data within specific 
value intervals, such as time ranges or numeric sequences. 

Join Operations: In cases of data linking through multiple collections, indexes improve join efficiency, 
consolidating data from various sources promptly.

Types of MongoDB Indexes:- 
MongoDB offers various indexing options, each designed to optimize specific data access patterns and 
query scenarios. Understanding the different types of indexes is essential for harnessing MongoDB’s full 
potential in terms of query performance, data retrieval, and overall database efficiency. From simple
single-field indexes to compound, text, and geospatial indexes, each type plays a crucial role in enhancing 
the speed and accuracy of data access.
 
Single Field Indexes 
Single field indexes in MongoDB are a fundamental indexing strategy that significantly impacts query 
performance by expediting data retrieval based on a specific field. These indexes efficiently handle queries 
involving the indexed field, notably minimizing the necessity for full collection scans. They are especially 
advantageous for tasks such as filtering, sorting, or searching data based on a single attribute. For example, 
when queries frequently focus on unique user identifications or timestamps, a single field index can 
profoundly enhance query execution, ensuring prompt and responsive data access. 

Compound Indexes 
Compound indexes in MongoDB play a crucial role in optimizing queries that involve multiple fields. 
These indexes encompass more than one field and allow for enhanced query performance by facilitating 
the retrieval of data based on various attributes simultaneously. The order of fields in a compound index 
holds immense importance as it directly affects its efficiency in addressing specific query patterns. This 
order influences how the index is used; queries that match the order of fields in the index benefit the most. 
Careful consideration of the order in which fields are placed within a compound index can significantly 
impact query efficiency and overall database performance.
 
Multikey Indexes 
Multikey indexes in MongoDB are indexing tools that involve arrays and nested documents and are 
particularly useful when dealing with fields containing arrays or documents that hold multiple values. A 
multikey index generates separate index entries for each value within an array or nested document, 
enabling efficient querying and filtering based on these nested values. While multikey indexes offer 
benefits like enhanced query performance for array-based searches, it’s crucial to consider potential 
downsides, such as increased index size and write operations’ impact. 

Text Indexes 
In MongoDB, these enable full-text search functionality within the database, making it easier to search for 
and retrieve relevant information from large collections of text data. Text indexes are particularly 
beneficial when natural language processing and text-based analysis are essential. Uses include content 
management systems, social media platforms, and e-commerce sites, where users need to locate specific 
textual content within datasets.  

Geospatial Indexes 
Geospatial indexes in MongoDB are designed to facilitate the efficient retrieval of location-based 
information, like proximity searches, polygon intersections, and distance-based analyses. They are 
particularly valuable in applications that involve geographic data, such as mapping and navigation 
systems, location-based services, and real estate platforms, providing responsive and accurate information 
and enhancing user experiences. 

Hashed Indexes 
Hashed indexes in MongoDB are specialized indexing tools for distributing data uniformly across a 
collection. Unlike other index types, hashed indexes use a hashing algorithm to map field values to index 
keys, ensuring even distribution. This approach is particularly beneficial for scenarios where write
intensive workloads are prevalent. In such cases, hashed indexes can mitigate issues related to index 
contention and hotspots, distributing write operations across the index evenly. Hashed indexes excel when 
the primary concern is maintaining consistent performance in high-write environments, such as in 
applications with rapidly changing data.
 

Limitations And Challenges Of Mongodb Indexes:- 

While MongoDB indexes offer significant benefits, they also come with certain limitations and challenges: 
Index Size: Many indexes can lead to large storage requirements. 
Write Operations: Additional indexes slow down write operations. 
Query Planning: Poorly chosen indexes might lead to inefficient query execution plans. 
Index Updates: Frequent updates can lead to index fragmentation, impacting performance.





Command:

use ShrutikaBDA

db.Students.insertMany([{roll_no:1, name: "Shrutika", age:21, marks:85, city:"Delhi"} ])

#Single Field
db.Students.createIndex({"city": 1})

db.Students.find({city: "Delhi"}).explain("executionStats");


#Compound Field
db.Students.createIndex({city: 1, age: -1});

db.Students.find({city:"Delhi"}).sort({age: -1}).explain("executionStats");

#Unique Index
db.Students.createIndex({roll_no: 1},{unique:true})

db.Students.insertOne({roll_no: 1, name: "Anjali", age: 22, marks: 90, city: "Mumbai"});

#Text Index
db.Students.createIndex({name:"text"})

db.Students.find({$text: {$search: "Shrutika"}}).explain("executionStats");



db.Students.dropIndex({"city": 1});



